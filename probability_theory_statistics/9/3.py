# (Дополнительно). Произвести вычисления как в пункте 2, но с вычислением intercept.
# Учесть, что изменение коэффициентов должно производиться на каждом шаге одновременно
# (то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации).

import numpy as np


def mse(b0, b1, y, x, n):
    return np.sum((b1 * x + b0 - y) ** 2) / n


a = 7e-5
x = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
y = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
n = len(x)
b0 = 0.1
b1 = 0.1
for i in range(1000001):
    if i % 2 == 0:
        b0 -= a * (2 / n) * np.sum((b1 * x + b0 - y))
    else:
        b1 -= a * (2 / n) * np.sum((b1 * x + b0 - y) * x)
    if i % 100000 == 0:
        print(f'i = {i}, b0 = {b0}, b1 = {b1}, mse = {mse(b0, b1, y, x, n)}')
